/* imhiredis.c
* Copyright 2021 aDvens
*
* This file is contrib for rsyslog.
* This input plugin is a log consumer from REDIS
* See README for doc
*
*
* This program is free software: you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public License
* as published by the Free Software Foundation, either version 3 of
* the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this program. If not, see
* <http://www.gnu.org/licenses/>.
*
* Author: Jérémie Jourdin
* <jeremie.jourdin@advens.fr>
*/

#include "config.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/uio.h>
#include <hiredis/hiredis.h>
#include <hiredis/async.h>
#include <hiredis/adapters/libevent.h>
#include <event2/thread.h>

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhiredis")

/* static data */
DEF_IMOD_STATIC_DATA
#define QUEUE_BATCH_SIZE 10
#define IMHIREDIS_MODE_QUEUE 1
#define IMHIREDIS_MODE_SUBSCRIBE 2
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)


struct instanceConf_s {
	uchar *server;
	int port;
	uchar *password;
	uchar *key;
	uchar *modeDescription;
	int mode;
	sbool useLPop;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */

	redisContext *conn;
	redisAsyncContext *aconn;
	struct event_base *evtBase;

	struct instanceConf_s *next;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};

/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct imhiredisWrkrInfo_s {
	pthread_t tid;		/* the worker's thread ID */
	instanceConf_t *inst;	/* Pointer to imhiredis instance */
} *imhiredisWrkrInfo;

/* GLOBAL DATA */
pthread_attr_t wrkrThrdAttr;	/* Attribute for worker threads ; read only after startup */
static int activeHiredisworkers = 0;
static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "uselpop", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

struct timeval redis_connect_timeout = { 1, 500000 }; /* 1.5 seconds */


#include "im-helper.h" /* must be included AFTER the type definitions! */


/* forward references */
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
rsRetVal redisAuthenticate(instanceConf_t *inst);
rsRetVal redisConnectSync(instanceConf_t *inst);
rsRetVal redisConnectAsync(instanceConf_t *inst);
rsRetVal redisDequeue(instanceConf_t *inst);
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
static void *imhirediswrkr(void *myself);


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst->next = NULL;
	inst->server = NULL;
	inst->port = 0;
	inst->password = NULL;
	inst->key = NULL;
	inst->mode = 0;
	inst->useLPop = 0;
	inst->pszBindRuleset = NULL;
	inst->pBindRuleset = NULL;
	/* Redis objects */
	inst->conn = NULL;
	inst->aconn = NULL;
	/* libevent base for async connection */
	inst->evtBase = NULL;

	/* node created, let's add to config */
	if(loadModConf->tail == NULL) {
		loadModConf->tail = loadModConf->root = inst;
	} else {
		loadModConf->tail->next = inst;
		loadModConf->tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;

	/* check and print redis connection settings */
	if (inst->server != NULL && inst->server[0] != '\0') {
		DBGPRINTF("imhiredis: server is '%s'\n", inst->server);
	}
	else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: error: no server defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst->port != 0) {
		DBGPRINTF("imhiredis: port is '%d'\n", inst->port);
	}
	else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: error: no port defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst->key != NULL) {
		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst->key);
	}
	else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: error: no key defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst->mode != IMHIREDIS_MODE_QUEUE && inst->mode != IMHIREDIS_MODE_SUBSCRIBE) {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst->mode == IMHIREDIS_MODE_SUBSCRIBE && inst->useLPop) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");

	}

	if (inst->password != NULL) {
		DBGPRINTF("imhiredis: password is '%s'\n", inst->password);
	}


finalize_it:
	RETiRet;
}

/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
		"using default ruleset instead",
		inst->pszBindRuleset);
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhiredis)\n");

	if((pvals = nvlstGetParams(lst, &inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("input param blk in imhiredis:\n");
		cnfparamsPrint(&inppblk, pvals);
	}

	CHKiRet(createInstance(&inst));
	for(i = 0 ; i < inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;

		if(!strcmp(inppblk.descr[i].name, "server")) {
			inst->server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst->pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "port")) {
			inst->port = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "password")) {
			inst->password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
			inst->useLPop = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
			inst->modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if (!strcmp((const char*)inst->modeDescription, "queue")) {
				inst->mode = IMHIREDIS_MODE_QUEUE;
			} else if (!strcmp((const char*)inst->modeDescription, "subscribe")) {
				inst->mode = IMHIREDIS_MODE_SUBSCRIBE;
			} else {
				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
					"'%s'", inppblk.descr[i].name);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
		} else if(!strcmp(inppblk.descr[i].name, "key")) {
			inst->key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("imhiredis: program error, non-handled "
				"param '%s'\n", inppblk.descr[i].name);
		}
	}

	DBGPRINTF("imhiredis: checking config sanity\n");
	if (inst->modeDescription == NULL) {
		CHKmalloc(inst->modeDescription = (uchar*)strdup("subscribe"));
		inst->mode = IMHIREDIS_MODE_SUBSCRIBE;
		LogMsg(0, NO_ERRCODE, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
			"using default redis 'subscribe' mode -- this may not be what you want!");
	}
	if (inst->key == NULL) {
		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	if(inst->server == NULL) {
		CHKmalloc(inst->server = (uchar *)strdup("127.0.0.1"));
		LogMsg(0, NO_ERRCODE, LOG_WARNING, "imhiredis: \"server\" parameter not specified "
			"using default of 127.0.0.1 -- this may not be what you want!");
	}
	if (inst->password == NULL) {
		LogMsg(0, NO_ERRCODE, LOG_INFO, "imhiredis: no password specified");
	}

	DBGPRINTF("imhiredis: newInpIns server=%s, port=%d, key=%s, mode=%s, uselpop=%d\n",
		inst->server, inst->port, inst->key, inst->modeDescription, inst->useLPop);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf->pConf = pConf;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imhiredis:\n");
		cnfparamsPrint(&modpblk, pvals);
	}

	for(i = 0 ; i < modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		}
		else {
			dbgprintf("imhiredis: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf->root ; inst != NULL ; inst = inst->next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf->root ; inst != NULL ; inst = inst->next) {
		iRet = checkInstance(inst);
		if (inst->mode == IMHIREDIS_MODE_SUBSCRIBE)
			inst->evtBase = event_base_new();
	}
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf->root ; inst != NULL ; ) {
		if (inst->evtBase)
			event_base_free(inst->evtBase);
		if (inst->password != NULL)
			free(inst->password);
		free(inst->server);
		free(inst->modeDescription);
		free(inst->key);
		free(inst->pszBindRuleset);
		del = inst;
		inst = inst->next;
		free(del);
	}
ENDfreeCnf


/* Cleanup imhiredis worker threads */
static void
shutdownImhiredisWorkers(void)
{
	int i;
	instanceConf_t *inst;

	assert(imhiredisWrkrInfo != NULL);

	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
		if (inst->mode == IMHIREDIS_MODE_SUBSCRIBE && inst->aconn) {
			DBGPRINTF("imhiredis: disconnecting async worker\n");
			redisAsyncDisconnect(inst->aconn);
		}
	}

	// event_base_loopbreak(runModConf->evtBase);

	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
	for(i = 0 ; i < activeHiredisworkers ; ++i) {
		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
	}
	free(imhiredisWrkrInfo);
	imhiredisWrkrInfo = NULL;

	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
		DBGPRINTF("imhiredis: stop consuming %s:%d/%s\n",
			inst->server, inst->port, inst->key);
		if(inst->conn != NULL) {
			redisFree(inst->conn);
			inst->conn = NULL;
		}
		if(inst->aconn != NULL) {
			redisAsyncFree(inst->aconn);
			inst->aconn = NULL;
		}
		DBGPRINTF("imhiredis: stopped consuming %s:%d/%s\n",
			inst->server, inst->port, inst->key);
	}
}


/* This function is called to gather input.  */
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imhiredis: runInput loop started ...\n");
	activeHiredisworkers = 0;
	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
		++activeHiredisworkers;
	}

	if(activeHiredisworkers == 0) {
		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}


	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
	if (imhiredisWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	/* Start worker threads for each imhiredis input source
	*/
	i = 0;
	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
		/* init worker info structure! */
		imhiredisWrkrInfo[i].inst = inst; /* Set reference pointer */
		pthread_create(&imhiredisWrkrInfo[i].tid, &wrkrThrdAttr, imhirediswrkr, &(imhiredisWrkrInfo[i]));
		i++;
	}

	// This thread simply runs the various threads, then waits for Rsyslog to stop
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			/* Check termination state every 100ms
			 * should be sufficient to grant fast response to shutdown while not hogging CPU
			 */
			srSleep(0, 100000);
	}
	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");

	shutdownImhiredisWorkers();
finalize_it:
ENDrunInput


BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&pInputName);

ENDafterRun


BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&wrkrThrdAttr);

	/* force cleaning of all libevent-related structures
	 * (clean shutdowns are not always guaranteed without it)
	 */
	libevent_global_shutdown();

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* initialize "read-only" thread attributes */
	pthread_attr_init(&wrkrThrdAttr);
	pthread_attr_setstacksize(&wrkrThrdAttr, 4096*1024);

	/* activate libevent for (p)threads support */
	evthread_use_pthreads();

ENDmodInit


/* ------------------------------ callbacks ------------------------------ */


/**
 * Asynchronous subscribe callback handler
 */
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj) {
	/*
		redisReply is supposed to be an array of three elements: [''message', <channel>, <message>]


		JJO: For future reference (https://github.com/redis/hiredis/blob/master/README.md)

		Important: the current version of hiredis (1.0.0) frees replies when the asynchronous API is used.
		This means you should not call freeReplyObject when you use this API.
		The reply is cleaned up by hiredis after the callback returns.
		TODO We may have to change this function in the future to free replies.
	*/
	instanceConf_t *const inst = (instanceConf_t *) inst_obj;
  	redisReply * r = (redisReply *) reply;
  	if (r == NULL) return;

	if (r->element[2]->str == NULL) {
		return;
	}
	enqMsg(inst, r->element[2]->str);

	return;
}


/**
 * Asynchronous connection callback handler
 */
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
			"%s", c->errstr);
		// remove async context from instance config object, still contained in context's 'data' field
		instanceConf_t *inst = (instanceConf_t *) c->data;
		assert(inst != NULL);
		inst->aconn = NULL;
		return;
	}
	DBGPRINTF("imhiredis (async): successfully connected!\n");

	return;
}


/**
 * Asynchronous disconnection callback handler
 */
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {

	// remove context from instance config object (which is stored in the context 'data' field by us)
	// context will be freed by the library, so it's only set to NULL here
	instanceConf_t *inst = (instanceConf_t *) c->data;
	assert(inst != NULL);
	inst->aconn = NULL;

	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
			"%s", c->errstr);
		return;
	}
	DBGPRINTF("imhiredis (async): successfully disconnected!\n");

	return;
}


/* ------------------------------ end callbacks ------------------------------ */


/* enqueue the hiredis message. The provided string is
 * not freed - this must be done by the caller.
 */
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
	DEFiRet;
	smsg_t *pMsg;

	if (message == NULL || message[0] == '\0') {
		/* we do not process empty lines */
		FINALIZE;
	}

	DBGPRINTF("imhiredis: enqMsg: Msg -> '%s'\n", message);

	CHKiRet(msgConstruct(&pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, message, strlen(message));
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst->pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	CHKiRet(submitMsg2(pMsg));

finalize_it:
	RETiRet;
}


/*
 *	authentication function, for both synchronous and asynchronous modes (queue or subscribe)
 */
rsRetVal redisAuthenticate(instanceConf_t *inst) {
	DEFiRet;
	redisContext *usedContext = NULL;
	redisReply *reply = NULL;

	assert(inst != NULL);
	assert(inst->password != NULL);
	assert(inst->password[0] != '\0');

	DBGPRINTF("imhiredis: authenticating...\n");

	// Create a temporary context for synchronous connection, used to validate AUTH command in asynchronous contexts
	if (inst->mode == IMHIREDIS_MODE_SUBSCRIBE) {
		usedContext = redisConnectWithTimeout((const char *)inst->server, inst->port, redis_connect_timeout);
		if (usedContext == NULL || usedContext->err) {
			if (usedContext) {
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
					"port %d -> %s\n", inst->server, inst->port, usedContext->errstr);
			}
			else {
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
					"port %d -> could not allocate context!\n", inst->server, inst->port);
			}
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	} else {
		usedContext = inst->conn;
	}

	// Try synchronous connection, whatever the method for the instance
	// This is also done for the asynchronous mode, to validate the successful authentication
	reply = (redisReply *) redisCommand(usedContext, "AUTH %s", inst->password);
	if (reply == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (strncmp(reply->str, "OK", 2)) {
		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -> %s\n", reply->str);
		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
	}

	// For asynchronous connection, resend the auth command once first synchronous call was successful
	if (inst->mode == IMHIREDIS_MODE_SUBSCRIBE) {
		assert(inst->aconn != NULL);
		if (REDIS_OK != redisAsyncCommand(inst->aconn, NULL, inst, "AUTH %s", inst->password)) {
			LogError(0, NO_ERRCODE, "imhiredis: error while authenticating asynchronously -> %s\n",
				inst->aconn->errstr);
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	}

	DBGPRINTF("imhiredis: authentication successful\n");

finalize_it:
	if(inst->mode == IMHIREDIS_MODE_SUBSCRIBE && usedContext)
		redisFree(usedContext);
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	connection function for synchronous (queue) mode
 */
rsRetVal redisConnectSync(instanceConf_t *inst) {
	DBGPRINTF("imhiredis: connecting...\n");
	DEFiRet;

	assert(inst != NULL);
	assert(inst->conn == NULL);

	inst->conn = redisConnectWithTimeout((const char *)inst->server, inst->port, redis_connect_timeout);

	if (inst->conn == NULL || inst->conn->err) {
		if (inst->conn) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -> %s\n", inst->server, inst->port, inst->conn->errstr);
		}
		else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -> could not allocate context!\n", inst->server, inst->port);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

	DBGPRINTF("imhiredis: successfully connected!\n");

finalize_it:
	if (iRet != RS_RET_OK) {
		if (inst->conn)
			redisFree(inst->conn);
		inst->conn = NULL;
	}
	RETiRet;
}


/*
 *	connection function for asynchronous (subscribe) mode
 */
rsRetVal redisConnectAsync(instanceConf_t *inst) {
	DBGPRINTF("imhiredis (async): connecting...\n");
	DEFiRet;

	assert(inst != NULL);
	assert(inst->aconn == NULL);
	assert(inst->evtBase != NULL);

	inst->aconn = redisAsyncConnect((const char *)inst->server, inst->port);
	if(inst->aconn == NULL ) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (inst->aconn->err) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d'\n",
		inst->server,
		inst->port);
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	// save the instance params in available data pointer (this pointer is provided for applications)
	inst->aconn->data = (void *)inst;

	redisAsyncSetConnectCallback(inst->aconn, redisAsyncConnectCallback);
    	redisAsyncSetDisconnectCallback(inst->aconn, redisAsyncDisconnectCallback);
	redisLibeventAttach(inst->aconn, inst->evtBase);

finalize_it:
	if (iRet != RS_RET_OK) {
		if(inst->aconn)
			redisAsyncFree(inst->aconn);
		inst->aconn = NULL;
	}
	RETiRet;
}


rsRetVal redisDequeue(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	uint replyType = 0, i;

	assert(inst != NULL);

	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst->key);

	do {
		// append a batch of QUEUE_BATCH_SIZE POP commands (either LPOP or RPOP depending on conf)
		if (inst->useLPop == 1) {
			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst->key);
			for (i=0; i<QUEUE_BATCH_SIZE; ++i ) {
				if (REDIS_OK != redisAppendCommand(inst->conn, "LPOP %s", inst->key))
					break;
			}
		} else {
			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst->key);
			for (i=0; i<QUEUE_BATCH_SIZE; i++) {
				if (REDIS_OK != redisAppendCommand(inst->conn, "RPOP %s", inst->key))
					break;
			}
		}

		// parse responses from appended commands
		do {
			if (REDIS_OK != redisGetReply(inst->conn, (void **) &reply)) {
				// error getting reply, must stop
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
								"'%s'", (QUEUE_BATCH_SIZE - i), inst->key);
				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
			} else {
				if (reply != NULL) {
					replyType = reply->type;
					switch(replyType) {
						case REDIS_REPLY_STRING:
							enqMsg(inst, reply->str);
							break;
						case REDIS_REPLY_NIL:
							// replies are dequeued but are empty = end of list
							break;
						case REDIS_REPLY_ERROR:
							// There is a problem with the key or the Redis instance
							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
							"while POP'ing key '%s' -> %s", inst->key, reply->str);
							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
						default:
							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
							"reply type: %s", redis_replies[replyType%7]);
					}
					freeReplyObject(reply);
					reply = NULL;
				} else { /* reply == NULL */
					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
						"for successful return");
					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
				}
			}

		// while there are replies to unpack, continue
		} while (--i > 0);

	// while input can run and last reply was a string, continue with a new batch
	} while (replyType == REDIS_REPLY_STRING && glbl.GetGlobalInputTermState() == 0);

	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst->key);

finalize_it:
	if (reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	worker function for asynchronous (subscribe) mode
 */
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");

	// Connect first time without delay
	if(RS_RET_OK == redisConnectAsync(me->inst) && me->inst->password != NULL && me->inst->password[0] != '\0') {
		if(RS_RET_OK != redisAuthenticate(me->inst)) {
			redisAsyncFree(me->inst->aconn);
			me->inst->aconn = NULL;
		}
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me->inst->aconn == NULL) {
			/* Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			for(i = 0; i < 100; i++) {
				// Rsyslog asked for shutdown, thread should be stopped
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			if(RS_RET_OK == redisConnectAsync(me->inst)
				&& me->inst->password != NULL
				&& me->inst->password[0] != '\0') {
				if(RS_RET_OK != redisAuthenticate(me->inst)) {
					redisAsyncFree(me->inst->aconn);
					me->inst->aconn = NULL;
				}
			}
		}
		if (me->inst->aconn != NULL) {
			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me->inst->key);
			redisAsyncCommand(
				me->inst->aconn,
				redisAsyncRecvCallback,
				me->inst,
				"SUBSCRIBE %s",
				me->inst->key);
			event_base_dispatch(me->inst->evtBase);
		}
	}

end_loop:
	return;
}


/*
 *	worker function for synchronous (queue) mode
 */
void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
	// Connect first time without delay
	if(RS_RET_OK == redisConnectSync(me->inst) && me->inst->password != NULL && me->inst->password[0] != '\0') {
		if(RS_RET_OK != redisAuthenticate(me->inst)) {
			redisFree(me->inst->conn);
			me->inst->conn = NULL;
		}
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me->inst->conn == NULL) {
			/* Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			for(i = 0; i < 100; i++) {
				// Time to stop the thread
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			if(RS_RET_OK == redisConnectSync(me->inst)
				&& me->inst->password != NULL
				&& me->inst->password[0] != '\0') {
				if(RS_RET_OK != redisAuthenticate(me->inst)) {
					redisFree(me->inst->conn);
					me->inst->conn = NULL;
				}
			}
		}
		if (me->inst->conn != NULL) {
			if (redisDequeue(me->inst) == RS_RET_REDIS_ERROR) {
				DBGPRINTF("imhiredis: current connection invalidated\n");
				redisFree(me->inst->conn);
				me->inst->conn = NULL;
			}

		}
		if(glbl.GetGlobalInputTermState() == 0)
			/* sleep 1s between 2 POP tries
			 * this does NOT limit dequeing rate, but prevents the input from polling Redis too often
			 */
			for(i = 0; i < 10; i++) {
				// Time to stop the thread
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}
	}

end_loop:
	return;
}


/*
 *	Workerthread function for a single hiredis consumer
 */
static void *
imhirediswrkr(void *myself)
{
	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
	DBGPRINTF("imhiredis: started hiredis consumer workerthread on %s:%d/%s\n",
		me->inst->server, me->inst->port, me->inst->key);

	if(me->inst->mode == IMHIREDIS_MODE_QUEUE)
		workerLoopQueue(me);
	else if (me->inst->mode == IMHIREDIS_MODE_SUBSCRIBE)
		workerLoopSubscribe(me);

	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread on %s:%d/%s\n",
		me->inst->server, me->inst->port, me->inst->key);
	return NULL;
}
